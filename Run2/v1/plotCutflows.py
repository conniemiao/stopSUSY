#!/usr/bin/env python

# NOTE: NEEDS 2 CMD LINE ARGS with values:
# testMode {test, all}, displayMode {show, save}, channel {mumu, elel, muel},
# region {A,B,C,D}
#
# Draws the cutflow for some channel and a piechart from both no cuts and
# after all cuts showing the breakdown of the bkgd.
# Uses the output generated by generateCutflows.py.

print "Importing modules."
import sys, os
from ROOT import TFile, TH1D, TCanvas, TImage, TLegend, TText, THStack, TPie
from ROOT import gSystem, gStyle, gROOT, kTRUE
from collections import OrderedDict
import numpy as np
import pandas as pd
import time
from array import array
print "Beginning execution of", sys.argv

# location where the cutflow stats were saved
statsDir = "/afs/cern.ch/user/c/cmiao/private/CMSSW_9_4_9/s2019_SUSY/plots/Run2/v1/cutflow_stats"
# location where the cutflow plots will be saved
cutflowPlotsDir = "/afs/cern.ch/user/c/cmiao/private/CMSSW_9_4_9/s2019_SUSY/plots/Run2/v1/cutflow"

assert len(sys.argv) == 5, "needs 4 command line args: testMode{0,1}, displayMode {show, save}, channel {mumu, elel, muel}, region {A,B,C,D}"

if sys.argv[1] == "test": testMode = True
elif sys.argv[1] == "all": testMode = False
else: assert False, "invalid test mode, need {test, all}"

if sys.argv[2] == "show": displayMode = True
elif sys.argv[2] == "save": displayMode = False
else: assert False, "invalid display mode, need {show, save}"

# selecting for either mu-mu or el-el (as opposed to mu-el or el-mu)
if sys.argv[3] == "mumu":
    findingSameFlavor = True
    muPreference = True
    l1Flav = "Muon"
    l2Flav = "Muon"
    dataProcess = "DoubleMuon"
elif sys.argv[3] == "elel":
    findingSameFlavor = True
    muPreference = False
    l1Flav = "Electron"
    l2Flav = "Electron"
    dataProcess = "DoubleEG"
elif sys.argv[3] == "muel":
    findingSameFlavor = False
    muPreference = False
    l1Flav = "Muon"
    l2Flav = "Electron"
    dataProcess = "MuonEG"
else: assert False, "invalid channel, need {mumu, elel, muel}"
channel = l1Flav[:2] + l2Flav[:2]

region = sys.argv[4]
assert region == "any" or region == "A" or region == "B" or region == "C" or region == "D", "invalid region, need {any, A, B, C, D}"

# bkgd process name : color for plotting
processes = OrderedDict([("W-Jets",38), ("Drell-Yan",46), ("TTBar",30), \
        ("Diboson",41), ("Single-Top",40), ("TT+X",7)])

if not displayMode:
    if not os.path.exists(cutflowPlotsDir): os.makedirs(cutflowPlotsDir)
    gROOT.SetBatch(kTRUE) # prevent displaying canvases

#--------------------------------------------------------------------------------#

statsFileAdr = statsDir+"/cutflow_stats_"+channel+"_"+region+".hdf"
print "Reading from", statsFileAdr
statsDF = pd.read_hdf(statsFileAdr, "statsDF")

cuts = list(statsDF.index.values) # cuts names
nCuts = len(cuts)
hBkgdCutsCountDict = {} # maps process to arr of cutflow counts for that process
hBkgdDict = {} # maps process to an hBkgd for that process
hSigCutsCountDict = {} # maps sig name to arr of cutflow counts for that sig 
hSigDict = {} # maps sig name to an hSig for that sig 
for inputProcess in statsDF.columns:
    cutflowArr = statsDF.loc[:,inputProcess] # get the column for inputProcess
    if inputProcess[:4] == "Stop": 
        hSigCutsCountDict.update({inputProcess:cutflowArr})
        hSig = TH1D("sig_" + inputProcess, inputProcess, nCuts, 0, nCuts)
        hSig.SetDirectory(0) # necessary to keep hist from closing
        hSig.SetDefaultSumw2() # automatically sum w^2 while filling
        hSigDict.update({inputProcess:hSig})
    elif inputProcess == "data":
        hDataCutsCountArr = cutflowArr
        hData = TH1D("data", "data", nCuts, 0, nCuts)
        hData.SetDirectory(0)
        hData.SetDefaultSumw2() # automatically sum w^2 while filling
    else: 
        hBkgdCutsCountDict.update({inputProcess:cutflowArr})
        hBkgd = TH1D("bkgd_"+inputProcess, inputProcess, nCuts, 0, nCuts)
        hBkgd.SetDirectory(0)
        hBkgd.SetDefaultSumw2() # automatically sum w^2 while filling
        hBkgdDict.update({inputProcess:hBkgd})
for process in processes:
    if process not in hBkgdDict: processes.pop(process)
    # doing it this way so can still stack in the desired order (by using the 
    # ordered dict)

c = TCanvas("c_cutflow","c_cutflow",10,20,1000,700)
legend = TLegend(.45,.75,.90,.90)
title = "cutflow ("+channel+")"
hBkgdStack = THStack("cutflow_bkgdStack", title)
nEvtsLabels = []
gStyle.SetOptStat(0) # don't show any stats

lumi = 3000000 # luminosity = 3 /ab = 3000 /fb = 3,000,000 /fb

# ********** Looping over each bkgd process. ***********
for process in processes:
    hBkgd = hBkgdDict[process] 
    hBkgdCutsCount = hBkgdCutsCountDict[process]
    for i, cut in enumerate(cuts):
        if i>nCuts: break
        hBkgd.Fill(i, hBkgdCutsCount[i])
        hBkgd.GetXaxis().SetBinLabel(i+1, cut)

    c.cd()
    # hBkgd.Sumw2() # already summed while filling
    hBkgd.SetFillColor(processes[process])
    hBkgd.SetLineColor(processes[process])
    hBkgdStack.Add(hBkgd)
    legend.AddEntry(hBkgd, process+"_bkgd")

hBkgdStack.Draw("hist")
hBkgdStack.GetXaxis().SetTitle("cutflow")
hBkgdStack.GetYaxis().SetTitle("Number of Events, norm to 3000 /fb")
hBkgdStack.SetMinimum(1)
hBkgdStack.SetMaximum(10**12)

# # show the number of events left over after each cut
# processNum = 0
# for process, color in processes.items():
#     print
#     print "Num surviving events after each cut from bkgd %s:" % process 
#     for i, cut in enumerate(cuts):
#         nEvtsLabel = TText()
#         nEvtsLabel.SetNDC()
#         nEvtsLabel.SetTextSize(0.02)
#         nEvtsLabel.SetTextAlign(22)
#         nEvtsLabel.SetTextAngle(0)
#         nEvtsLabel.SetTextColor(color)
#         nEvtsLabel.DrawText(0.1+0.4/nCuts+0.8*float(i)/nCuts, \
#                 0.7-(processNum)*0.02, \
#                 str(int(hBkgdCutsCountDict[process][i])))
#         print cut, hBkgdCutsCountDict[process][i]
#         nEvtsLabels.append(nEvtsLabel)
#     processNum += 1
# print

#--------------------------------------------------------------------------------#
# *************** Filling each signal in a separate hist  ************
print "Plotting from signal."

coloropts = [2,4,3,6,7,9,28,46] # some good colors for lines
markeropts = [1,20,21,22,23] # some good marker styles for lines
linestyleopts = [1,2,3,7,9] # some good styles for lines

for fileNum, sig in enumerate(hSigCutsCountDict.keys()):
    hSig = hSigDict[sig] 
    hSigCutsCount = hSigCutsCountDict[sig]
    for i, cut in enumerate(cuts):
        if i>nCuts: break
        hSig.Fill(i, hSigCutsCount[i])
        hSig.GetXaxis().SetBinLabel(i+1, cut)

    hcolor = coloropts[fileNum % len(coloropts)]
    hmarkerstyle = markeropts[(fileNum/len(coloropts)) % len(markeropts)]

    hSig.SetLineColor(hcolor) 
    hSig.SetMarkerStyle(hmarkerstyle)
    hSig.SetMarkerColor(hcolor)
    hlinestyle = linestyleopts[(fileNum/len(coloropts)/len(markeropts)) % \
            len(linestyleopts)]
    hSig.SetLineStyle(hlinestyle)

    legend.AddEntry(hSig, hSig.GetTitle())
    hSig.Draw("hist same") # same pad

    # # show the number of events left over after each cut
    # print "Num surviving events after each cut from sig %s:" % filename 
    # for i, cut in enumerate(cuts):
    #     print cut, hSig.GetBinContent(i+1)
    #     nEvtsLabel = TText()
    #     nEvtsLabel.SetNDC()
    #     nEvtsLabel.SetTextSize(0.02)
    #     nEvtsLabel.SetTextAlign(22)
    #     nEvtsLabel.SetTextAngle(0)
    #     nEvtsLabel.SetTextColor(hcolor)
    #     nEvtsLabel.DrawText(0.1+0.4/nCuts+0.8*float(i)/nCuts, \
    #             0.7-(processNum)*0.02-(1+fileNum)*0.02, \
    #             str(int(hSig.GetBinContent(i+1))))
    #     nEvtsLabels.append(nEvtsLabel)
    # print

#--------------------------------------------------------------------------------#
# *************** Filling data in a separate hist  ************
for i, cut in enumerate(cuts):
    if i>nCuts: break
    hData.Fill(i, hDataCutsCountArr[i])
    hData.GetXaxis().SetBinLabel(i+1, cut)

hcolor = 1 # black
hmarkerstyle = 3 # asterisk (to match with the *H draw option)

hData.SetLineColor(hcolor) 
hData.SetMarkerStyle(hmarkerstyle)
hData.SetMarkerColor(hcolor)

legend.AddEntry(hData, hData.GetTitle())
hData.Draw("* hist same") # same pad

#--------------------------------------------------------------------------------#

print "Drawing cutflow."

legend.SetTextSize(0.02)
legend.SetNColumns(3)
legend.Draw("same")
c.SetLogy()
c.Update()

if displayMode:
    print "Done with cutflow."
else:
    gSystem.ProcessEvents()
    imgName = cutflowPlotsDir+"/cutflow_"+channel
    imgName += ".png"
    print "Saving image", imgName
    img = TImage.Create()
    img.FromPad(c)
    img.WriteImage(imgName)

#--------------------------------------------------------------------------------#
# *************** Draw pie charts ************
c.SetLogy(0) # unset logy
c_pie = TCanvas("c_pie","c_pie",10,10,700,700)

baselinePieVals = []
allcutsPieVals = []
pieColors = []
# to make sure you don't try to plot a pie chart when all entries are 0:
survivingEvts = False
for process in processes:
    baselinePieVals.append(hBkgdCutsCountDict[process][0])
    allcutsPieVals.append(hBkgdCutsCountDict[process][nCuts-1])
    if hBkgdCutsCountDict[process][nCuts-1] > 0: survivingEvts = True
    pieColors.append(processes[process])

baselinePie = TPie("baselinePie", "Bkgd breakdown, no cuts ("+channel+")", \
        len(baselinePieVals), array('f',baselinePieVals))
baselinePie.SetLabelFormat("#splitline{%txt}{%val (%perc)}")
baselinePie.SetFillColors(array('i',pieColors))
baselinePie.SetValueFormat("%.0f")
baselinePie.SetTextSize(0.02)
baselinePie.SetRadius(0.3)

lastcut = cuts[nCuts-1]
allcutsPie = TPie("allcutsPie", "Bkgd breakdown, "+lastcut+"("+channel+")", \
        len(allcutsPieVals), array('f',allcutsPieVals))
allcutsPie.SetLabelFormat("#splitline{%txt}{%val (%perc)}")
allcutsPie.SetFillColors(array('i',pieColors))
allcutsPie.SetValueFormat("%.0f")
allcutsPie.SetTextSize(0.02)
allcutsPie.SetRadius(0.3)

for i, process in enumerate(processes):
    baselinePie.SetEntryLabel(i, process)
    allcutsPie.SetEntryLabel(i, process)

c_pie.cd()
baselinePie.Draw("nol sc")
c_pie.Update()
if displayMode:
    print "Done with baseline pie. Press enter to finish."
    raw_input()
else:
    gSystem.ProcessEvents()
    imgName = cutflowPlotsDir+"/pie_baseline_"+channel
    imgName += ".png"
    print "Saving image", imgName
    img = TImage.Create()
    img.FromPad(c_pie)
    img.WriteImage(imgName)

if survivingEvts:
    c_pie.cd()
    allcutsPie.Draw("nol sc")
    c_pie.Update()
    if displayMode:
        print "Done with all cuts pie. Press enter to finish."
        raw_input()
    else:
        gSystem.ProcessEvents()
        imgName = cutflowPlotsDir+"/pie_"+lastcut+"_"+channel
        imgName += ".png"
        print "Saving image", imgName
        img = TImage.Create()
        img.FromPad(c)
        img.WriteImage(imgName)
        print "Done."
